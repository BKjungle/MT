// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "ImFile.pb.h"

@implementation ImFileRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [ImFileRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    [ImBaseDefineRoot registerAllExtensions:registry];
    extensionRegistry = [registry retain];
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface IMFileLoginReq ()
@property int32_t userId;
@property (retain) NSString* taskId;
@property ClientFileRole fileRole;
@end

@implementation IMFileLoginReq

- (BOOL) hasUserId {
  return !!hasUserId_;
}
- (void) setHasUserId:(BOOL) value {
  hasUserId_ = !!value;
}
@synthesize userId;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
- (BOOL) hasFileRole {
  return !!hasFileRole_;
}
- (void) setHasFileRole:(BOOL) value {
  hasFileRole_ = !!value;
}
@synthesize fileRole;
- (void) dealloc {
  self.taskId = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.userId = 0;
    self.taskId = @"";
    self.fileRole = ClientFileRoleClientRealtimeSender;
  }
  return self;
}
static IMFileLoginReq* defaultIMFileLoginReqInstance = nil;
+ (void) initialize {
  if (self == [IMFileLoginReq class]) {
    defaultIMFileLoginReqInstance = [[IMFileLoginReq alloc] init];
  }
}
+ (IMFileLoginReq*) defaultInstance {
  return defaultIMFileLoginReqInstance;
}
- (IMFileLoginReq*) defaultInstance {
  return defaultIMFileLoginReqInstance;
}
- (BOOL) isInitialized {
  if (!self.hasUserId) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasFileRole) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasUserId) {
    [output writeUInt32:1 value:self.userId];
  }
  if (self.hasTaskId) {
    [output writeString:2 value:self.taskId];
  }
  if (self.hasFileRole) {
    [output writeEnum:3 value:self.fileRole];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasUserId) {
    size += computeUInt32Size(1, self.userId);
  }
  if (self.hasTaskId) {
    size += computeStringSize(2, self.taskId);
  }
  if (self.hasFileRole) {
    size += computeEnumSize(3, self.fileRole);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileLoginReq*) parseFromData:(NSData*) data {
  return (IMFileLoginReq*)[[[IMFileLoginReq builder] mergeFromData:data] build];
}
+ (IMFileLoginReq*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileLoginReq*)[[[IMFileLoginReq builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileLoginReq*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileLoginReq*)[[[IMFileLoginReq builder] mergeFromInputStream:input] build];
}
+ (IMFileLoginReq*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileLoginReq*)[[[IMFileLoginReq builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileLoginReq*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileLoginReq*)[[[IMFileLoginReq builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileLoginReq*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileLoginReq*)[[[IMFileLoginReq builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileLoginReq*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileLoginReq*)[[[IMFileLoginReq builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileLoginReq_Builder*) builder {
  return [[[IMFileLoginReq_Builder alloc] init] autorelease];
}
+ (IMFileLoginReq_Builder*) builderWithPrototype:(IMFileLoginReq*) prototype {
  return [[IMFileLoginReq builder] mergeFrom:prototype];
}
- (IMFileLoginReq_Builder*) builder {
  return [IMFileLoginReq builder];
}
@end

@interface IMFileLoginReq_Builder()
@property (retain) IMFileLoginReq* result;
@end

@implementation IMFileLoginReq_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileLoginReq alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileLoginReq_Builder*) clear {
  self.result = [[[IMFileLoginReq alloc] init] autorelease];
  return self;
}
- (IMFileLoginReq_Builder*) clone {
  return [IMFileLoginReq builderWithPrototype:result];
}
- (IMFileLoginReq*) defaultInstance {
  return [IMFileLoginReq defaultInstance];
}
- (IMFileLoginReq*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileLoginReq*) buildPartial {
  IMFileLoginReq* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileLoginReq_Builder*) mergeFrom:(IMFileLoginReq*) other {
  if (other == [IMFileLoginReq defaultInstance]) {
    return self;
  }
  if (other.hasUserId) {
    [self setUserId:other.userId];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.hasFileRole) {
    [self setFileRole:other.fileRole];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileLoginReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileLoginReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setUserId:[input readUInt32]];
        break;
      }
      case 18: {
        [self setTaskId:[input readString]];
        break;
      }
      case 24: {
        int32_t value = [input readEnum];
        if (ClientFileRoleIsValidValue(value)) {
          [self setFileRole:value];
        } else {
          [unknownFields mergeVarintField:3 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasUserId {
  return result.hasUserId;
}
- (int32_t) userId {
  return result.userId;
}
- (IMFileLoginReq_Builder*) setUserId:(int32_t) value {
  result.hasUserId = YES;
  result.userId = value;
  return self;
}
- (IMFileLoginReq_Builder*) clearUserId {
  result.hasUserId = NO;
  result.userId = 0;
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFileLoginReq_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFileLoginReq_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (BOOL) hasFileRole {
  return result.hasFileRole;
}
- (ClientFileRole) fileRole {
  return result.fileRole;
}
- (IMFileLoginReq_Builder*) setFileRole:(ClientFileRole) value {
  result.hasFileRole = YES;
  result.fileRole = value;
  return self;
}
- (IMFileLoginReq_Builder*) clearFileRole {
  result.hasFileRole = NO;
  result.fileRole = ClientFileRoleClientRealtimeSender;
  return self;
}
@end

@interface IMFileLoginRsp ()
@property int32_t resultCode;
@property (retain) NSString* taskId;
@end

@implementation IMFileLoginRsp

- (BOOL) hasResultCode {
  return !!hasResultCode_;
}
- (void) setHasResultCode:(BOOL) value {
  hasResultCode_ = !!value;
}
@synthesize resultCode;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
- (void) dealloc {
  self.taskId = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.resultCode = 0;
    self.taskId = @"";
  }
  return self;
}
static IMFileLoginRsp* defaultIMFileLoginRspInstance = nil;
+ (void) initialize {
  if (self == [IMFileLoginRsp class]) {
    defaultIMFileLoginRspInstance = [[IMFileLoginRsp alloc] init];
  }
}
+ (IMFileLoginRsp*) defaultInstance {
  return defaultIMFileLoginRspInstance;
}
- (IMFileLoginRsp*) defaultInstance {
  return defaultIMFileLoginRspInstance;
}
- (BOOL) isInitialized {
  if (!self.hasResultCode) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasResultCode) {
    [output writeUInt32:1 value:self.resultCode];
  }
  if (self.hasTaskId) {
    [output writeString:2 value:self.taskId];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasResultCode) {
    size += computeUInt32Size(1, self.resultCode);
  }
  if (self.hasTaskId) {
    size += computeStringSize(2, self.taskId);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileLoginRsp*) parseFromData:(NSData*) data {
  return (IMFileLoginRsp*)[[[IMFileLoginRsp builder] mergeFromData:data] build];
}
+ (IMFileLoginRsp*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileLoginRsp*)[[[IMFileLoginRsp builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileLoginRsp*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileLoginRsp*)[[[IMFileLoginRsp builder] mergeFromInputStream:input] build];
}
+ (IMFileLoginRsp*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileLoginRsp*)[[[IMFileLoginRsp builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileLoginRsp*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileLoginRsp*)[[[IMFileLoginRsp builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileLoginRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileLoginRsp*)[[[IMFileLoginRsp builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileLoginRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileLoginRsp*)[[[IMFileLoginRsp builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileLoginRsp_Builder*) builder {
  return [[[IMFileLoginRsp_Builder alloc] init] autorelease];
}
+ (IMFileLoginRsp_Builder*) builderWithPrototype:(IMFileLoginRsp*) prototype {
  return [[IMFileLoginRsp builder] mergeFrom:prototype];
}
- (IMFileLoginRsp_Builder*) builder {
  return [IMFileLoginRsp builder];
}
@end

@interface IMFileLoginRsp_Builder()
@property (retain) IMFileLoginRsp* result;
@end

@implementation IMFileLoginRsp_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileLoginRsp alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileLoginRsp_Builder*) clear {
  self.result = [[[IMFileLoginRsp alloc] init] autorelease];
  return self;
}
- (IMFileLoginRsp_Builder*) clone {
  return [IMFileLoginRsp builderWithPrototype:result];
}
- (IMFileLoginRsp*) defaultInstance {
  return [IMFileLoginRsp defaultInstance];
}
- (IMFileLoginRsp*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileLoginRsp*) buildPartial {
  IMFileLoginRsp* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileLoginRsp_Builder*) mergeFrom:(IMFileLoginRsp*) other {
  if (other == [IMFileLoginRsp defaultInstance]) {
    return self;
  }
  if (other.hasResultCode) {
    [self setResultCode:other.resultCode];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileLoginRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileLoginRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setResultCode:[input readUInt32]];
        break;
      }
      case 18: {
        [self setTaskId:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasResultCode {
  return result.hasResultCode;
}
- (int32_t) resultCode {
  return result.resultCode;
}
- (IMFileLoginRsp_Builder*) setResultCode:(int32_t) value {
  result.hasResultCode = YES;
  result.resultCode = value;
  return self;
}
- (IMFileLoginRsp_Builder*) clearResultCode {
  result.hasResultCode = NO;
  result.resultCode = 0;
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFileLoginRsp_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFileLoginRsp_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
@end

@interface IMFileState ()
@property ClientFileState state;
@property TransferType ttype;
@property (retain) NSString* taskId;
@property int32_t userId;
@end

@implementation IMFileState

- (BOOL) hasState {
  return !!hasState_;
}
- (void) setHasState:(BOOL) value {
  hasState_ = !!value;
}
@synthesize state;
- (BOOL) hasTtype {
  return !!hasTtype_;
}
- (void) setHasTtype:(BOOL) value {
  hasTtype_ = !!value;
}
@synthesize ttype;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
- (BOOL) hasUserId {
  return !!hasUserId_;
}
- (void) setHasUserId:(BOOL) value {
  hasUserId_ = !!value;
}
@synthesize userId;
- (void) dealloc {
  self.taskId = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.state = ClientFileStateClientFilePeerReady;
    self.ttype = TransferTypeFileUpload;
    self.taskId = @"";
    self.userId = 0;
  }
  return self;
}
static IMFileState* defaultIMFileStateInstance = nil;
+ (void) initialize {
  if (self == [IMFileState class]) {
    defaultIMFileStateInstance = [[IMFileState alloc] init];
  }
}
+ (IMFileState*) defaultInstance {
  return defaultIMFileStateInstance;
}
- (IMFileState*) defaultInstance {
  return defaultIMFileStateInstance;
}
- (BOOL) isInitialized {
  if (!self.hasState) {
    return NO;
  }
  if (!self.hasTtype) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasUserId) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasState) {
    [output writeEnum:1 value:self.state];
  }
  if (self.hasTtype) {
    [output writeEnum:2 value:self.ttype];
  }
  if (self.hasTaskId) {
    [output writeString:3 value:self.taskId];
  }
  if (self.hasUserId) {
    [output writeUInt32:4 value:self.userId];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasState) {
    size += computeEnumSize(1, self.state);
  }
  if (self.hasTtype) {
    size += computeEnumSize(2, self.ttype);
  }
  if (self.hasTaskId) {
    size += computeStringSize(3, self.taskId);
  }
  if (self.hasUserId) {
    size += computeUInt32Size(4, self.userId);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileState*) parseFromData:(NSData*) data {
  return (IMFileState*)[[[IMFileState builder] mergeFromData:data] build];
}
+ (IMFileState*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileState*)[[[IMFileState builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileState*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileState*)[[[IMFileState builder] mergeFromInputStream:input] build];
}
+ (IMFileState*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileState*)[[[IMFileState builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileState*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileState*)[[[IMFileState builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileState*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileState*)[[[IMFileState builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileState*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileState*)[[[IMFileState builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileState_Builder*) builder {
  return [[[IMFileState_Builder alloc] init] autorelease];
}
+ (IMFileState_Builder*) builderWithPrototype:(IMFileState*) prototype {
  return [[IMFileState builder] mergeFrom:prototype];
}
- (IMFileState_Builder*) builder {
  return [IMFileState builder];
}
@end

@interface IMFileState_Builder()
@property (retain) IMFileState* result;
@end

@implementation IMFileState_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileState alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileState_Builder*) clear {
  self.result = [[[IMFileState alloc] init] autorelease];
  return self;
}
- (IMFileState_Builder*) clone {
  return [IMFileState builderWithPrototype:result];
}
- (IMFileState*) defaultInstance {
  return [IMFileState defaultInstance];
}
- (IMFileState*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileState*) buildPartial {
  IMFileState* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileState_Builder*) mergeFrom:(IMFileState*) other {
  if (other == [IMFileState defaultInstance]) {
    return self;
  }
  if (other.hasState) {
    [self setState:other.state];
  }
  if (other.hasTtype) {
    [self setTtype:other.ttype];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.hasUserId) {
    [self setUserId:other.userId];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileState_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileState_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        int32_t value = [input readEnum];
        if (ClientFileStateIsValidValue(value)) {
          [self setState:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 16: {
        int32_t value = [input readEnum];
        if (TransferTypeIsValidValue(value)) {
          [self setTtype:value];
        } else {
          [unknownFields mergeVarintField:2 value:value];
        }
        break;
      }
      case 26: {
        [self setTaskId:[input readString]];
        break;
      }
      case 32: {
        [self setUserId:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasState {
  return result.hasState;
}
- (ClientFileState) state {
  return result.state;
}
- (IMFileState_Builder*) setState:(ClientFileState) value {
  result.hasState = YES;
  result.state = value;
  return self;
}
- (IMFileState_Builder*) clearState {
  result.hasState = NO;
  result.state = ClientFileStateClientFilePeerReady;
  return self;
}
- (BOOL) hasTtype {
  return result.hasTtype;
}
- (TransferType) ttype {
  return result.ttype;
}
- (IMFileState_Builder*) setTtype:(TransferType) value {
  result.hasTtype = YES;
  result.ttype = value;
  return self;
}
- (IMFileState_Builder*) clearTtype {
  result.hasTtype = NO;
  result.ttype = TransferTypeFileUpload;
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFileState_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFileState_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (BOOL) hasUserId {
  return result.hasUserId;
}
- (int32_t) userId {
  return result.userId;
}
- (IMFileState_Builder*) setUserId:(int32_t) value {
  result.hasUserId = YES;
  result.userId = value;
  return self;
}
- (IMFileState_Builder*) clearUserId {
  result.hasUserId = NO;
  result.userId = 0;
  return self;
}
@end

@interface IMFilePullDataReq ()
@property (retain) NSString* taskId;
@property int32_t userId;
@property TransferFileType transMode;
@property int32_t offset;
@property int32_t dataSize;
@end

@implementation IMFilePullDataReq

- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
- (BOOL) hasUserId {
  return !!hasUserId_;
}
- (void) setHasUserId:(BOOL) value {
  hasUserId_ = !!value;
}
@synthesize userId;
- (BOOL) hasTransMode {
  return !!hasTransMode_;
}
- (void) setHasTransMode:(BOOL) value {
  hasTransMode_ = !!value;
}
@synthesize transMode;
- (BOOL) hasOffset {
  return !!hasOffset_;
}
- (void) setHasOffset:(BOOL) value {
  hasOffset_ = !!value;
}
@synthesize offset;
- (BOOL) hasDataSize {
  return !!hasDataSize_;
}
- (void) setHasDataSize:(BOOL) value {
  hasDataSize_ = !!value;
}
@synthesize dataSize;
- (void) dealloc {
  self.taskId = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.taskId = @"";
    self.userId = 0;
    self.transMode = TransferFileTypeFileTypeOnline;
    self.offset = 0;
    self.dataSize = 0;
  }
  return self;
}
static IMFilePullDataReq* defaultIMFilePullDataReqInstance = nil;
+ (void) initialize {
  if (self == [IMFilePullDataReq class]) {
    defaultIMFilePullDataReqInstance = [[IMFilePullDataReq alloc] init];
  }
}
+ (IMFilePullDataReq*) defaultInstance {
  return defaultIMFilePullDataReqInstance;
}
- (IMFilePullDataReq*) defaultInstance {
  return defaultIMFilePullDataReqInstance;
}
- (BOOL) isInitialized {
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasUserId) {
    return NO;
  }
  if (!self.hasTransMode) {
    return NO;
  }
  if (!self.hasOffset) {
    return NO;
  }
  if (!self.hasDataSize) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasTaskId) {
    [output writeString:1 value:self.taskId];
  }
  if (self.hasUserId) {
    [output writeUInt32:2 value:self.userId];
  }
  if (self.hasTransMode) {
    [output writeEnum:3 value:self.transMode];
  }
  if (self.hasOffset) {
    [output writeUInt32:4 value:self.offset];
  }
  if (self.hasDataSize) {
    [output writeUInt32:5 value:self.dataSize];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasTaskId) {
    size += computeStringSize(1, self.taskId);
  }
  if (self.hasUserId) {
    size += computeUInt32Size(2, self.userId);
  }
  if (self.hasTransMode) {
    size += computeEnumSize(3, self.transMode);
  }
  if (self.hasOffset) {
    size += computeUInt32Size(4, self.offset);
  }
  if (self.hasDataSize) {
    size += computeUInt32Size(5, self.dataSize);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFilePullDataReq*) parseFromData:(NSData*) data {
  return (IMFilePullDataReq*)[[[IMFilePullDataReq builder] mergeFromData:data] build];
}
+ (IMFilePullDataReq*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFilePullDataReq*)[[[IMFilePullDataReq builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFilePullDataReq*) parseFromInputStream:(NSInputStream*) input {
  return (IMFilePullDataReq*)[[[IMFilePullDataReq builder] mergeFromInputStream:input] build];
}
+ (IMFilePullDataReq*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFilePullDataReq*)[[[IMFilePullDataReq builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFilePullDataReq*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFilePullDataReq*)[[[IMFilePullDataReq builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFilePullDataReq*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFilePullDataReq*)[[[IMFilePullDataReq builder] mergeFromCodedInputStream:input] build];
}
+ (IMFilePullDataReq*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFilePullDataReq*)[[[IMFilePullDataReq builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFilePullDataReq_Builder*) builder {
  return [[[IMFilePullDataReq_Builder alloc] init] autorelease];
}
+ (IMFilePullDataReq_Builder*) builderWithPrototype:(IMFilePullDataReq*) prototype {
  return [[IMFilePullDataReq builder] mergeFrom:prototype];
}
- (IMFilePullDataReq_Builder*) builder {
  return [IMFilePullDataReq builder];
}
@end

@interface IMFilePullDataReq_Builder()
@property (retain) IMFilePullDataReq* result;
@end

@implementation IMFilePullDataReq_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFilePullDataReq alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFilePullDataReq_Builder*) clear {
  self.result = [[[IMFilePullDataReq alloc] init] autorelease];
  return self;
}
- (IMFilePullDataReq_Builder*) clone {
  return [IMFilePullDataReq builderWithPrototype:result];
}
- (IMFilePullDataReq*) defaultInstance {
  return [IMFilePullDataReq defaultInstance];
}
- (IMFilePullDataReq*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFilePullDataReq*) buildPartial {
  IMFilePullDataReq* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFilePullDataReq_Builder*) mergeFrom:(IMFilePullDataReq*) other {
  if (other == [IMFilePullDataReq defaultInstance]) {
    return self;
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.hasUserId) {
    [self setUserId:other.userId];
  }
  if (other.hasTransMode) {
    [self setTransMode:other.transMode];
  }
  if (other.hasOffset) {
    [self setOffset:other.offset];
  }
  if (other.hasDataSize) {
    [self setDataSize:other.dataSize];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFilePullDataReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFilePullDataReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setTaskId:[input readString]];
        break;
      }
      case 16: {
        [self setUserId:[input readUInt32]];
        break;
      }
      case 24: {
        int32_t value = [input readEnum];
        if (TransferFileTypeIsValidValue(value)) {
          [self setTransMode:value];
        } else {
          [unknownFields mergeVarintField:3 value:value];
        }
        break;
      }
      case 32: {
        [self setOffset:[input readUInt32]];
        break;
      }
      case 40: {
        [self setDataSize:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFilePullDataReq_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFilePullDataReq_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (BOOL) hasUserId {
  return result.hasUserId;
}
- (int32_t) userId {
  return result.userId;
}
- (IMFilePullDataReq_Builder*) setUserId:(int32_t) value {
  result.hasUserId = YES;
  result.userId = value;
  return self;
}
- (IMFilePullDataReq_Builder*) clearUserId {
  result.hasUserId = NO;
  result.userId = 0;
  return self;
}
- (BOOL) hasTransMode {
  return result.hasTransMode;
}
- (TransferFileType) transMode {
  return result.transMode;
}
- (IMFilePullDataReq_Builder*) setTransMode:(TransferFileType) value {
  result.hasTransMode = YES;
  result.transMode = value;
  return self;
}
- (IMFilePullDataReq_Builder*) clearTransMode {
  result.hasTransMode = NO;
  result.transMode = TransferFileTypeFileTypeOnline;
  return self;
}
- (BOOL) hasOffset {
  return result.hasOffset;
}
- (int32_t) offset {
  return result.offset;
}
- (IMFilePullDataReq_Builder*) setOffset:(int32_t) value {
  result.hasOffset = YES;
  result.offset = value;
  return self;
}
- (IMFilePullDataReq_Builder*) clearOffset {
  result.hasOffset = NO;
  result.offset = 0;
  return self;
}
- (BOOL) hasDataSize {
  return result.hasDataSize;
}
- (int32_t) dataSize {
  return result.dataSize;
}
- (IMFilePullDataReq_Builder*) setDataSize:(int32_t) value {
  result.hasDataSize = YES;
  result.dataSize = value;
  return self;
}
- (IMFilePullDataReq_Builder*) clearDataSize {
  result.hasDataSize = NO;
  result.dataSize = 0;
  return self;
}
@end

@interface IMFilePullDataRsp ()
@property int32_t resultCode;
@property (retain) NSString* taskId;
@property int32_t userId;
@property int32_t offset;
@property (retain) NSData* fileData;
@end

@implementation IMFilePullDataRsp

- (BOOL) hasResultCode {
  return !!hasResultCode_;
}
- (void) setHasResultCode:(BOOL) value {
  hasResultCode_ = !!value;
}
@synthesize resultCode;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
- (BOOL) hasUserId {
  return !!hasUserId_;
}
- (void) setHasUserId:(BOOL) value {
  hasUserId_ = !!value;
}
@synthesize userId;
- (BOOL) hasOffset {
  return !!hasOffset_;
}
- (void) setHasOffset:(BOOL) value {
  hasOffset_ = !!value;
}
@synthesize offset;
- (BOOL) hasFileData {
  return !!hasFileData_;
}
- (void) setHasFileData:(BOOL) value {
  hasFileData_ = !!value;
}
@synthesize fileData;
- (void) dealloc {
  self.taskId = nil;
  self.fileData = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.resultCode = 0;
    self.taskId = @"";
    self.userId = 0;
    self.offset = 0;
    self.fileData = [NSData data];
  }
  return self;
}
static IMFilePullDataRsp* defaultIMFilePullDataRspInstance = nil;
+ (void) initialize {
  if (self == [IMFilePullDataRsp class]) {
    defaultIMFilePullDataRspInstance = [[IMFilePullDataRsp alloc] init];
  }
}
+ (IMFilePullDataRsp*) defaultInstance {
  return defaultIMFilePullDataRspInstance;
}
- (IMFilePullDataRsp*) defaultInstance {
  return defaultIMFilePullDataRspInstance;
}
- (BOOL) isInitialized {
  if (!self.hasResultCode) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasUserId) {
    return NO;
  }
  if (!self.hasOffset) {
    return NO;
  }
  if (!self.hasFileData) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasResultCode) {
    [output writeUInt32:1 value:self.resultCode];
  }
  if (self.hasTaskId) {
    [output writeString:2 value:self.taskId];
  }
  if (self.hasUserId) {
    [output writeUInt32:3 value:self.userId];
  }
  if (self.hasOffset) {
    [output writeUInt32:4 value:self.offset];
  }
  if (self.hasFileData) {
    [output writeData:5 value:self.fileData];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasResultCode) {
    size += computeUInt32Size(1, self.resultCode);
  }
  if (self.hasTaskId) {
    size += computeStringSize(2, self.taskId);
  }
  if (self.hasUserId) {
    size += computeUInt32Size(3, self.userId);
  }
  if (self.hasOffset) {
    size += computeUInt32Size(4, self.offset);
  }
  if (self.hasFileData) {
    size += computeDataSize(5, self.fileData);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFilePullDataRsp*) parseFromData:(NSData*) data {
  return (IMFilePullDataRsp*)[[[IMFilePullDataRsp builder] mergeFromData:data] build];
}
+ (IMFilePullDataRsp*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFilePullDataRsp*)[[[IMFilePullDataRsp builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFilePullDataRsp*) parseFromInputStream:(NSInputStream*) input {
  return (IMFilePullDataRsp*)[[[IMFilePullDataRsp builder] mergeFromInputStream:input] build];
}
+ (IMFilePullDataRsp*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFilePullDataRsp*)[[[IMFilePullDataRsp builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFilePullDataRsp*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFilePullDataRsp*)[[[IMFilePullDataRsp builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFilePullDataRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFilePullDataRsp*)[[[IMFilePullDataRsp builder] mergeFromCodedInputStream:input] build];
}
+ (IMFilePullDataRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFilePullDataRsp*)[[[IMFilePullDataRsp builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFilePullDataRsp_Builder*) builder {
  return [[[IMFilePullDataRsp_Builder alloc] init] autorelease];
}
+ (IMFilePullDataRsp_Builder*) builderWithPrototype:(IMFilePullDataRsp*) prototype {
  return [[IMFilePullDataRsp builder] mergeFrom:prototype];
}
- (IMFilePullDataRsp_Builder*) builder {
  return [IMFilePullDataRsp builder];
}
@end

@interface IMFilePullDataRsp_Builder()
@property (retain) IMFilePullDataRsp* result;
@end

@implementation IMFilePullDataRsp_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFilePullDataRsp alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFilePullDataRsp_Builder*) clear {
  self.result = [[[IMFilePullDataRsp alloc] init] autorelease];
  return self;
}
- (IMFilePullDataRsp_Builder*) clone {
  return [IMFilePullDataRsp builderWithPrototype:result];
}
- (IMFilePullDataRsp*) defaultInstance {
  return [IMFilePullDataRsp defaultInstance];
}
- (IMFilePullDataRsp*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFilePullDataRsp*) buildPartial {
  IMFilePullDataRsp* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFilePullDataRsp_Builder*) mergeFrom:(IMFilePullDataRsp*) other {
  if (other == [IMFilePullDataRsp defaultInstance]) {
    return self;
  }
  if (other.hasResultCode) {
    [self setResultCode:other.resultCode];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.hasUserId) {
    [self setUserId:other.userId];
  }
  if (other.hasOffset) {
    [self setOffset:other.offset];
  }
  if (other.hasFileData) {
    [self setFileData:other.fileData];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFilePullDataRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFilePullDataRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setResultCode:[input readUInt32]];
        break;
      }
      case 18: {
        [self setTaskId:[input readString]];
        break;
      }
      case 24: {
        [self setUserId:[input readUInt32]];
        break;
      }
      case 32: {
        [self setOffset:[input readUInt32]];
        break;
      }
      case 42: {
        [self setFileData:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasResultCode {
  return result.hasResultCode;
}
- (int32_t) resultCode {
  return result.resultCode;
}
- (IMFilePullDataRsp_Builder*) setResultCode:(int32_t) value {
  result.hasResultCode = YES;
  result.resultCode = value;
  return self;
}
- (IMFilePullDataRsp_Builder*) clearResultCode {
  result.hasResultCode = NO;
  result.resultCode = 0;
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFilePullDataRsp_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFilePullDataRsp_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (BOOL) hasUserId {
  return result.hasUserId;
}
- (int32_t) userId {
  return result.userId;
}
- (IMFilePullDataRsp_Builder*) setUserId:(int32_t) value {
  result.hasUserId = YES;
  result.userId = value;
  return self;
}
- (IMFilePullDataRsp_Builder*) clearUserId {
  result.hasUserId = NO;
  result.userId = 0;
  return self;
}
- (BOOL) hasOffset {
  return result.hasOffset;
}
- (int32_t) offset {
  return result.offset;
}
- (IMFilePullDataRsp_Builder*) setOffset:(int32_t) value {
  result.hasOffset = YES;
  result.offset = value;
  return self;
}
- (IMFilePullDataRsp_Builder*) clearOffset {
  result.hasOffset = NO;
  result.offset = 0;
  return self;
}
- (BOOL) hasFileData {
  return result.hasFileData;
}
- (NSData*) fileData {
  return result.fileData;
}
- (IMFilePullDataRsp_Builder*) setFileData:(NSData*) value {
  result.hasFileData = YES;
  result.fileData = value;
  return self;
}
- (IMFilePullDataRsp_Builder*) clearFileData {
  result.hasFileData = NO;
  result.fileData = [NSData data];
  return self;
}
@end

@interface IMFileReq ()
@property int32_t fromUserId;
@property int32_t toUserId;
@property (retain) NSString* fileName;
@property int32_t fileSize;
@property TransferFileType transMode;
@property (retain) NSString* fileMd5;
@end

@implementation IMFileReq

- (BOOL) hasFromUserId {
  return !!hasFromUserId_;
}
- (void) setHasFromUserId:(BOOL) value {
  hasFromUserId_ = !!value;
}
@synthesize fromUserId;
- (BOOL) hasToUserId {
  return !!hasToUserId_;
}
- (void) setHasToUserId:(BOOL) value {
  hasToUserId_ = !!value;
}
@synthesize toUserId;
- (BOOL) hasFileName {
  return !!hasFileName_;
}
- (void) setHasFileName:(BOOL) value {
  hasFileName_ = !!value;
}
@synthesize fileName;
- (BOOL) hasFileSize {
  return !!hasFileSize_;
}
- (void) setHasFileSize:(BOOL) value {
  hasFileSize_ = !!value;
}
@synthesize fileSize;
- (BOOL) hasTransMode {
  return !!hasTransMode_;
}
- (void) setHasTransMode:(BOOL) value {
  hasTransMode_ = !!value;
}
@synthesize transMode;
- (BOOL) hasFileMd5 {
  return !!hasFileMd5_;
}
- (void) setHasFileMd5:(BOOL) value {
  hasFileMd5_ = !!value;
}
@synthesize fileMd5;
- (void) dealloc {
  self.fileName = nil;
  self.fileMd5 = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fromUserId = 0;
    self.toUserId = 0;
    self.fileName = @"";
    self.fileSize = 0;
    self.transMode = TransferFileTypeFileTypeOnline;
    self.fileMd5 = @"";
  }
  return self;
}
static IMFileReq* defaultIMFileReqInstance = nil;
+ (void) initialize {
  if (self == [IMFileReq class]) {
    defaultIMFileReqInstance = [[IMFileReq alloc] init];
  }
}
+ (IMFileReq*) defaultInstance {
  return defaultIMFileReqInstance;
}
- (IMFileReq*) defaultInstance {
  return defaultIMFileReqInstance;
}
- (BOOL) isInitialized {
  if (!self.hasFromUserId) {
    return NO;
  }
  if (!self.hasToUserId) {
    return NO;
  }
  if (!self.hasFileName) {
    return NO;
  }
  if (!self.hasFileSize) {
    return NO;
  }
  if (!self.hasTransMode) {
    return NO;
  }
  if (!self.hasFileMd5) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFromUserId) {
    [output writeUInt32:1 value:self.fromUserId];
  }
  if (self.hasToUserId) {
    [output writeUInt32:2 value:self.toUserId];
  }
  if (self.hasFileName) {
    [output writeString:3 value:self.fileName];
  }
  if (self.hasFileSize) {
    [output writeUInt32:4 value:self.fileSize];
  }
  if (self.hasTransMode) {
    [output writeEnum:5 value:self.transMode];
  }
  if (self.hasFileMd5) {
    [output writeString:6 value:self.fileMd5];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFromUserId) {
    size += computeUInt32Size(1, self.fromUserId);
  }
  if (self.hasToUserId) {
    size += computeUInt32Size(2, self.toUserId);
  }
  if (self.hasFileName) {
    size += computeStringSize(3, self.fileName);
  }
  if (self.hasFileSize) {
    size += computeUInt32Size(4, self.fileSize);
  }
  if (self.hasTransMode) {
    size += computeEnumSize(5, self.transMode);
  }
  if (self.hasFileMd5) {
    size += computeStringSize(6, self.fileMd5);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileReq*) parseFromData:(NSData*) data {
  return (IMFileReq*)[[[IMFileReq builder] mergeFromData:data] build];
}
+ (IMFileReq*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileReq*)[[[IMFileReq builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileReq*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileReq*)[[[IMFileReq builder] mergeFromInputStream:input] build];
}
+ (IMFileReq*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileReq*)[[[IMFileReq builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileReq*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileReq*)[[[IMFileReq builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileReq*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileReq*)[[[IMFileReq builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileReq*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileReq*)[[[IMFileReq builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileReq_Builder*) builder {
  return [[[IMFileReq_Builder alloc] init] autorelease];
}
+ (IMFileReq_Builder*) builderWithPrototype:(IMFileReq*) prototype {
  return [[IMFileReq builder] mergeFrom:prototype];
}
- (IMFileReq_Builder*) builder {
  return [IMFileReq builder];
}
@end

@interface IMFileReq_Builder()
@property (retain) IMFileReq* result;
@end

@implementation IMFileReq_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileReq alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileReq_Builder*) clear {
  self.result = [[[IMFileReq alloc] init] autorelease];
  return self;
}
- (IMFileReq_Builder*) clone {
  return [IMFileReq builderWithPrototype:result];
}
- (IMFileReq*) defaultInstance {
  return [IMFileReq defaultInstance];
}
- (IMFileReq*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileReq*) buildPartial {
  IMFileReq* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileReq_Builder*) mergeFrom:(IMFileReq*) other {
  if (other == [IMFileReq defaultInstance]) {
    return self;
  }
  if (other.hasFromUserId) {
    [self setFromUserId:other.fromUserId];
  }
  if (other.hasToUserId) {
    [self setToUserId:other.toUserId];
  }
  if (other.hasFileName) {
    [self setFileName:other.fileName];
  }
  if (other.hasFileSize) {
    [self setFileSize:other.fileSize];
  }
  if (other.hasTransMode) {
    [self setTransMode:other.transMode];
  }
  if (other.hasFileMd5) {
    [self setFileMd5:other.fileMd5];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setFromUserId:[input readUInt32]];
        break;
      }
      case 16: {
        [self setToUserId:[input readUInt32]];
        break;
      }
      case 26: {
        [self setFileName:[input readString]];
        break;
      }
      case 32: {
        [self setFileSize:[input readUInt32]];
        break;
      }
      case 40: {
        int32_t value = [input readEnum];
        if (TransferFileTypeIsValidValue(value)) {
          [self setTransMode:value];
        } else {
          [unknownFields mergeVarintField:5 value:value];
        }
        break;
      }
      case 50: {
        [self setFileMd5:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasFromUserId {
  return result.hasFromUserId;
}
- (int32_t) fromUserId {
  return result.fromUserId;
}
- (IMFileReq_Builder*) setFromUserId:(int32_t) value {
  result.hasFromUserId = YES;
  result.fromUserId = value;
  return self;
}
- (IMFileReq_Builder*) clearFromUserId {
  result.hasFromUserId = NO;
  result.fromUserId = 0;
  return self;
}
- (BOOL) hasToUserId {
  return result.hasToUserId;
}
- (int32_t) toUserId {
  return result.toUserId;
}
- (IMFileReq_Builder*) setToUserId:(int32_t) value {
  result.hasToUserId = YES;
  result.toUserId = value;
  return self;
}
- (IMFileReq_Builder*) clearToUserId {
  result.hasToUserId = NO;
  result.toUserId = 0;
  return self;
}
- (BOOL) hasFileName {
  return result.hasFileName;
}
- (NSString*) fileName {
  return result.fileName;
}
- (IMFileReq_Builder*) setFileName:(NSString*) value {
  result.hasFileName = YES;
  result.fileName = value;
  return self;
}
- (IMFileReq_Builder*) clearFileName {
  result.hasFileName = NO;
  result.fileName = @"";
  return self;
}
- (BOOL) hasFileSize {
  return result.hasFileSize;
}
- (int32_t) fileSize {
  return result.fileSize;
}
- (IMFileReq_Builder*) setFileSize:(int32_t) value {
  result.hasFileSize = YES;
  result.fileSize = value;
  return self;
}
- (IMFileReq_Builder*) clearFileSize {
  result.hasFileSize = NO;
  result.fileSize = 0;
  return self;
}
- (BOOL) hasTransMode {
  return result.hasTransMode;
}
- (TransferFileType) transMode {
  return result.transMode;
}
- (IMFileReq_Builder*) setTransMode:(TransferFileType) value {
  result.hasTransMode = YES;
  result.transMode = value;
  return self;
}
- (IMFileReq_Builder*) clearTransMode {
  result.hasTransMode = NO;
  result.transMode = TransferFileTypeFileTypeOnline;
  return self;
}
- (BOOL) hasFileMd5 {
  return result.hasFileMd5;
}
- (NSString*) fileMd5 {
  return result.fileMd5;
}
- (IMFileReq_Builder*) setFileMd5:(NSString*) value {
  result.hasFileMd5 = YES;
  result.fileMd5 = value;
  return self;
}
- (IMFileReq_Builder*) clearFileMd5 {
  result.hasFileMd5 = NO;
  result.fileMd5 = @"";
  return self;
}
@end

@interface IMFileRsp ()
@property int32_t resultCode;
@property int32_t fromUserId;
@property int32_t toUserId;
@property (retain) NSString* fileName;
@property (retain) NSString* taskId;
@property (retain) NSMutableArray* mutableIpAddrListList;
@property TransferFileType transMode;
@end

@implementation IMFileRsp

- (BOOL) hasResultCode {
  return !!hasResultCode_;
}
- (void) setHasResultCode:(BOOL) value {
  hasResultCode_ = !!value;
}
@synthesize resultCode;
- (BOOL) hasFromUserId {
  return !!hasFromUserId_;
}
- (void) setHasFromUserId:(BOOL) value {
  hasFromUserId_ = !!value;
}
@synthesize fromUserId;
- (BOOL) hasToUserId {
  return !!hasToUserId_;
}
- (void) setHasToUserId:(BOOL) value {
  hasToUserId_ = !!value;
}
@synthesize toUserId;
- (BOOL) hasFileName {
  return !!hasFileName_;
}
- (void) setHasFileName:(BOOL) value {
  hasFileName_ = !!value;
}
@synthesize fileName;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
@synthesize mutableIpAddrListList;
- (BOOL) hasTransMode {
  return !!hasTransMode_;
}
- (void) setHasTransMode:(BOOL) value {
  hasTransMode_ = !!value;
}
@synthesize transMode;
- (void) dealloc {
  self.fileName = nil;
  self.taskId = nil;
  self.mutableIpAddrListList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.resultCode = 0;
    self.fromUserId = 0;
    self.toUserId = 0;
    self.fileName = @"";
    self.taskId = @"";
    self.transMode = TransferFileTypeFileTypeOnline;
  }
  return self;
}
static IMFileRsp* defaultIMFileRspInstance = nil;
+ (void) initialize {
  if (self == [IMFileRsp class]) {
    defaultIMFileRspInstance = [[IMFileRsp alloc] init];
  }
}
+ (IMFileRsp*) defaultInstance {
  return defaultIMFileRspInstance;
}
- (IMFileRsp*) defaultInstance {
  return defaultIMFileRspInstance;
}
- (NSArray*) ipAddrListList {
  return mutableIpAddrListList;
}
- (IpAddr*) ipAddrListAtIndex:(int32_t) index {
  id value = [mutableIpAddrListList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasResultCode) {
    return NO;
  }
  if (!self.hasFromUserId) {
    return NO;
  }
  if (!self.hasToUserId) {
    return NO;
  }
  if (!self.hasFileName) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasTransMode) {
    return NO;
  }
  for (IpAddr* element in self.ipAddrListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasResultCode) {
    [output writeUInt32:1 value:self.resultCode];
  }
  if (self.hasFromUserId) {
    [output writeUInt32:2 value:self.fromUserId];
  }
  if (self.hasToUserId) {
    [output writeUInt32:3 value:self.toUserId];
  }
  if (self.hasFileName) {
    [output writeString:4 value:self.fileName];
  }
  if (self.hasTaskId) {
    [output writeString:5 value:self.taskId];
  }
  for (IpAddr* element in self.ipAddrListList) {
    [output writeMessage:6 value:element];
  }
  if (self.hasTransMode) {
    [output writeEnum:7 value:self.transMode];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasResultCode) {
    size += computeUInt32Size(1, self.resultCode);
  }
  if (self.hasFromUserId) {
    size += computeUInt32Size(2, self.fromUserId);
  }
  if (self.hasToUserId) {
    size += computeUInt32Size(3, self.toUserId);
  }
  if (self.hasFileName) {
    size += computeStringSize(4, self.fileName);
  }
  if (self.hasTaskId) {
    size += computeStringSize(5, self.taskId);
  }
  for (IpAddr* element in self.ipAddrListList) {
    size += computeMessageSize(6, element);
  }
  if (self.hasTransMode) {
    size += computeEnumSize(7, self.transMode);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileRsp*) parseFromData:(NSData*) data {
  return (IMFileRsp*)[[[IMFileRsp builder] mergeFromData:data] build];
}
+ (IMFileRsp*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileRsp*)[[[IMFileRsp builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileRsp*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileRsp*)[[[IMFileRsp builder] mergeFromInputStream:input] build];
}
+ (IMFileRsp*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileRsp*)[[[IMFileRsp builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileRsp*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileRsp*)[[[IMFileRsp builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileRsp*)[[[IMFileRsp builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileRsp*)[[[IMFileRsp builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileRsp_Builder*) builder {
  return [[[IMFileRsp_Builder alloc] init] autorelease];
}
+ (IMFileRsp_Builder*) builderWithPrototype:(IMFileRsp*) prototype {
  return [[IMFileRsp builder] mergeFrom:prototype];
}
- (IMFileRsp_Builder*) builder {
  return [IMFileRsp builder];
}
@end

@interface IMFileRsp_Builder()
@property (retain) IMFileRsp* result;
@end

@implementation IMFileRsp_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileRsp alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileRsp_Builder*) clear {
  self.result = [[[IMFileRsp alloc] init] autorelease];
  return self;
}
- (IMFileRsp_Builder*) clone {
  return [IMFileRsp builderWithPrototype:result];
}
- (IMFileRsp*) defaultInstance {
  return [IMFileRsp defaultInstance];
}
- (IMFileRsp*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileRsp*) buildPartial {
  IMFileRsp* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileRsp_Builder*) mergeFrom:(IMFileRsp*) other {
  if (other == [IMFileRsp defaultInstance]) {
    return self;
  }
  if (other.hasResultCode) {
    [self setResultCode:other.resultCode];
  }
  if (other.hasFromUserId) {
    [self setFromUserId:other.fromUserId];
  }
  if (other.hasToUserId) {
    [self setToUserId:other.toUserId];
  }
  if (other.hasFileName) {
    [self setFileName:other.fileName];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.mutableIpAddrListList.count > 0) {
    if (result.mutableIpAddrListList == nil) {
      result.mutableIpAddrListList = [NSMutableArray array];
    }
    [result.mutableIpAddrListList addObjectsFromArray:other.mutableIpAddrListList];
  }
  if (other.hasTransMode) {
    [self setTransMode:other.transMode];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setResultCode:[input readUInt32]];
        break;
      }
      case 16: {
        [self setFromUserId:[input readUInt32]];
        break;
      }
      case 24: {
        [self setToUserId:[input readUInt32]];
        break;
      }
      case 34: {
        [self setFileName:[input readString]];
        break;
      }
      case 42: {
        [self setTaskId:[input readString]];
        break;
      }
      case 50: {
        IpAddr_Builder* subBuilder = [IpAddr builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addIpAddrList:[subBuilder buildPartial]];
        break;
      }
      case 56: {
        int32_t value = [input readEnum];
        if (TransferFileTypeIsValidValue(value)) {
          [self setTransMode:value];
        } else {
          [unknownFields mergeVarintField:7 value:value];
        }
        break;
      }
    }
  }
}
- (BOOL) hasResultCode {
  return result.hasResultCode;
}
- (int32_t) resultCode {
  return result.resultCode;
}
- (IMFileRsp_Builder*) setResultCode:(int32_t) value {
  result.hasResultCode = YES;
  result.resultCode = value;
  return self;
}
- (IMFileRsp_Builder*) clearResultCode {
  result.hasResultCode = NO;
  result.resultCode = 0;
  return self;
}
- (BOOL) hasFromUserId {
  return result.hasFromUserId;
}
- (int32_t) fromUserId {
  return result.fromUserId;
}
- (IMFileRsp_Builder*) setFromUserId:(int32_t) value {
  result.hasFromUserId = YES;
  result.fromUserId = value;
  return self;
}
- (IMFileRsp_Builder*) clearFromUserId {
  result.hasFromUserId = NO;
  result.fromUserId = 0;
  return self;
}
- (BOOL) hasToUserId {
  return result.hasToUserId;
}
- (int32_t) toUserId {
  return result.toUserId;
}
- (IMFileRsp_Builder*) setToUserId:(int32_t) value {
  result.hasToUserId = YES;
  result.toUserId = value;
  return self;
}
- (IMFileRsp_Builder*) clearToUserId {
  result.hasToUserId = NO;
  result.toUserId = 0;
  return self;
}
- (BOOL) hasFileName {
  return result.hasFileName;
}
- (NSString*) fileName {
  return result.fileName;
}
- (IMFileRsp_Builder*) setFileName:(NSString*) value {
  result.hasFileName = YES;
  result.fileName = value;
  return self;
}
- (IMFileRsp_Builder*) clearFileName {
  result.hasFileName = NO;
  result.fileName = @"";
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFileRsp_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFileRsp_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (NSArray*) ipAddrListList {
  if (result.mutableIpAddrListList == nil) { return [NSArray array]; }
  return result.mutableIpAddrListList;
}
- (IpAddr*) ipAddrListAtIndex:(int32_t) index {
  return [result ipAddrListAtIndex:index];
}
- (IMFileRsp_Builder*) replaceIpAddrListAtIndex:(int32_t) index with:(IpAddr*) value {
  [result.mutableIpAddrListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (IMFileRsp_Builder*) addAllIpAddrList:(NSArray*) values {
  if (result.mutableIpAddrListList == nil) {
    result.mutableIpAddrListList = [NSMutableArray array];
  }
  [result.mutableIpAddrListList addObjectsFromArray:values];
  return self;
}
- (IMFileRsp_Builder*) clearIpAddrListList {
  result.mutableIpAddrListList = nil;
  return self;
}
- (IMFileRsp_Builder*) addIpAddrList:(IpAddr*) value {
  if (result.mutableIpAddrListList == nil) {
    result.mutableIpAddrListList = [NSMutableArray array];
  }
  [result.mutableIpAddrListList addObject:value];
  return self;
}
- (BOOL) hasTransMode {
  return result.hasTransMode;
}
- (TransferFileType) transMode {
  return result.transMode;
}
- (IMFileRsp_Builder*) setTransMode:(TransferFileType) value {
  result.hasTransMode = YES;
  result.transMode = value;
  return self;
}
- (IMFileRsp_Builder*) clearTransMode {
  result.hasTransMode = NO;
  result.transMode = TransferFileTypeFileTypeOnline;
  return self;
}
@end

@interface IMFileNotify ()
@property int32_t fromUserId;
@property int32_t toUserId;
@property (retain) NSString* fileName;
@property int32_t fileSize;
@property (retain) NSString* taskId;
@property (retain) NSMutableArray* mutableIpAddrListList;
@property TransferFileType transMode;
@property int32_t offlineReady;
@end

@implementation IMFileNotify

- (BOOL) hasFromUserId {
  return !!hasFromUserId_;
}
- (void) setHasFromUserId:(BOOL) value {
  hasFromUserId_ = !!value;
}
@synthesize fromUserId;
- (BOOL) hasToUserId {
  return !!hasToUserId_;
}
- (void) setHasToUserId:(BOOL) value {
  hasToUserId_ = !!value;
}
@synthesize toUserId;
- (BOOL) hasFileName {
  return !!hasFileName_;
}
- (void) setHasFileName:(BOOL) value {
  hasFileName_ = !!value;
}
@synthesize fileName;
- (BOOL) hasFileSize {
  return !!hasFileSize_;
}
- (void) setHasFileSize:(BOOL) value {
  hasFileSize_ = !!value;
}
@synthesize fileSize;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
@synthesize mutableIpAddrListList;
- (BOOL) hasTransMode {
  return !!hasTransMode_;
}
- (void) setHasTransMode:(BOOL) value {
  hasTransMode_ = !!value;
}
@synthesize transMode;
- (BOOL) hasOfflineReady {
  return !!hasOfflineReady_;
}
- (void) setHasOfflineReady:(BOOL) value {
  hasOfflineReady_ = !!value;
}
@synthesize offlineReady;
- (void) dealloc {
  self.fileName = nil;
  self.taskId = nil;
  self.mutableIpAddrListList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fromUserId = 0;
    self.toUserId = 0;
    self.fileName = @"";
    self.fileSize = 0;
    self.taskId = @"";
    self.transMode = TransferFileTypeFileTypeOnline;
    self.offlineReady = 0;
  }
  return self;
}
static IMFileNotify* defaultIMFileNotifyInstance = nil;
+ (void) initialize {
  if (self == [IMFileNotify class]) {
    defaultIMFileNotifyInstance = [[IMFileNotify alloc] init];
  }
}
+ (IMFileNotify*) defaultInstance {
  return defaultIMFileNotifyInstance;
}
- (IMFileNotify*) defaultInstance {
  return defaultIMFileNotifyInstance;
}
- (NSArray*) ipAddrListList {
  return mutableIpAddrListList;
}
- (IpAddr*) ipAddrListAtIndex:(int32_t) index {
  id value = [mutableIpAddrListList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFromUserId) {
    return NO;
  }
  if (!self.hasToUserId) {
    return NO;
  }
  if (!self.hasFileName) {
    return NO;
  }
  if (!self.hasFileSize) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasTransMode) {
    return NO;
  }
  if (!self.hasOfflineReady) {
    return NO;
  }
  for (IpAddr* element in self.ipAddrListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFromUserId) {
    [output writeUInt32:1 value:self.fromUserId];
  }
  if (self.hasToUserId) {
    [output writeUInt32:2 value:self.toUserId];
  }
  if (self.hasFileName) {
    [output writeString:3 value:self.fileName];
  }
  if (self.hasFileSize) {
    [output writeUInt32:4 value:self.fileSize];
  }
  if (self.hasTaskId) {
    [output writeString:5 value:self.taskId];
  }
  for (IpAddr* element in self.ipAddrListList) {
    [output writeMessage:6 value:element];
  }
  if (self.hasTransMode) {
    [output writeEnum:7 value:self.transMode];
  }
  if (self.hasOfflineReady) {
    [output writeUInt32:8 value:self.offlineReady];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFromUserId) {
    size += computeUInt32Size(1, self.fromUserId);
  }
  if (self.hasToUserId) {
    size += computeUInt32Size(2, self.toUserId);
  }
  if (self.hasFileName) {
    size += computeStringSize(3, self.fileName);
  }
  if (self.hasFileSize) {
    size += computeUInt32Size(4, self.fileSize);
  }
  if (self.hasTaskId) {
    size += computeStringSize(5, self.taskId);
  }
  for (IpAddr* element in self.ipAddrListList) {
    size += computeMessageSize(6, element);
  }
  if (self.hasTransMode) {
    size += computeEnumSize(7, self.transMode);
  }
  if (self.hasOfflineReady) {
    size += computeUInt32Size(8, self.offlineReady);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileNotify*) parseFromData:(NSData*) data {
  return (IMFileNotify*)[[[IMFileNotify builder] mergeFromData:data] build];
}
+ (IMFileNotify*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileNotify*)[[[IMFileNotify builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileNotify*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileNotify*)[[[IMFileNotify builder] mergeFromInputStream:input] build];
}
+ (IMFileNotify*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileNotify*)[[[IMFileNotify builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileNotify*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileNotify*)[[[IMFileNotify builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileNotify*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileNotify*)[[[IMFileNotify builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileNotify*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileNotify*)[[[IMFileNotify builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileNotify_Builder*) builder {
  return [[[IMFileNotify_Builder alloc] init] autorelease];
}
+ (IMFileNotify_Builder*) builderWithPrototype:(IMFileNotify*) prototype {
  return [[IMFileNotify builder] mergeFrom:prototype];
}
- (IMFileNotify_Builder*) builder {
  return [IMFileNotify builder];
}
@end

@interface IMFileNotify_Builder()
@property (retain) IMFileNotify* result;
@end

@implementation IMFileNotify_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileNotify alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileNotify_Builder*) clear {
  self.result = [[[IMFileNotify alloc] init] autorelease];
  return self;
}
- (IMFileNotify_Builder*) clone {
  return [IMFileNotify builderWithPrototype:result];
}
- (IMFileNotify*) defaultInstance {
  return [IMFileNotify defaultInstance];
}
- (IMFileNotify*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileNotify*) buildPartial {
  IMFileNotify* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileNotify_Builder*) mergeFrom:(IMFileNotify*) other {
  if (other == [IMFileNotify defaultInstance]) {
    return self;
  }
  if (other.hasFromUserId) {
    [self setFromUserId:other.fromUserId];
  }
  if (other.hasToUserId) {
    [self setToUserId:other.toUserId];
  }
  if (other.hasFileName) {
    [self setFileName:other.fileName];
  }
  if (other.hasFileSize) {
    [self setFileSize:other.fileSize];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.mutableIpAddrListList.count > 0) {
    if (result.mutableIpAddrListList == nil) {
      result.mutableIpAddrListList = [NSMutableArray array];
    }
    [result.mutableIpAddrListList addObjectsFromArray:other.mutableIpAddrListList];
  }
  if (other.hasTransMode) {
    [self setTransMode:other.transMode];
  }
  if (other.hasOfflineReady) {
    [self setOfflineReady:other.offlineReady];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileNotify_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileNotify_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setFromUserId:[input readUInt32]];
        break;
      }
      case 16: {
        [self setToUserId:[input readUInt32]];
        break;
      }
      case 26: {
        [self setFileName:[input readString]];
        break;
      }
      case 32: {
        [self setFileSize:[input readUInt32]];
        break;
      }
      case 42: {
        [self setTaskId:[input readString]];
        break;
      }
      case 50: {
        IpAddr_Builder* subBuilder = [IpAddr builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addIpAddrList:[subBuilder buildPartial]];
        break;
      }
      case 56: {
        int32_t value = [input readEnum];
        if (TransferFileTypeIsValidValue(value)) {
          [self setTransMode:value];
        } else {
          [unknownFields mergeVarintField:7 value:value];
        }
        break;
      }
      case 64: {
        [self setOfflineReady:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasFromUserId {
  return result.hasFromUserId;
}
- (int32_t) fromUserId {
  return result.fromUserId;
}
- (IMFileNotify_Builder*) setFromUserId:(int32_t) value {
  result.hasFromUserId = YES;
  result.fromUserId = value;
  return self;
}
- (IMFileNotify_Builder*) clearFromUserId {
  result.hasFromUserId = NO;
  result.fromUserId = 0;
  return self;
}
- (BOOL) hasToUserId {
  return result.hasToUserId;
}
- (int32_t) toUserId {
  return result.toUserId;
}
- (IMFileNotify_Builder*) setToUserId:(int32_t) value {
  result.hasToUserId = YES;
  result.toUserId = value;
  return self;
}
- (IMFileNotify_Builder*) clearToUserId {
  result.hasToUserId = NO;
  result.toUserId = 0;
  return self;
}
- (BOOL) hasFileName {
  return result.hasFileName;
}
- (NSString*) fileName {
  return result.fileName;
}
- (IMFileNotify_Builder*) setFileName:(NSString*) value {
  result.hasFileName = YES;
  result.fileName = value;
  return self;
}
- (IMFileNotify_Builder*) clearFileName {
  result.hasFileName = NO;
  result.fileName = @"";
  return self;
}
- (BOOL) hasFileSize {
  return result.hasFileSize;
}
- (int32_t) fileSize {
  return result.fileSize;
}
- (IMFileNotify_Builder*) setFileSize:(int32_t) value {
  result.hasFileSize = YES;
  result.fileSize = value;
  return self;
}
- (IMFileNotify_Builder*) clearFileSize {
  result.hasFileSize = NO;
  result.fileSize = 0;
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFileNotify_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFileNotify_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (NSArray*) ipAddrListList {
  if (result.mutableIpAddrListList == nil) { return [NSArray array]; }
  return result.mutableIpAddrListList;
}
- (IpAddr*) ipAddrListAtIndex:(int32_t) index {
  return [result ipAddrListAtIndex:index];
}
- (IMFileNotify_Builder*) replaceIpAddrListAtIndex:(int32_t) index with:(IpAddr*) value {
  [result.mutableIpAddrListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (IMFileNotify_Builder*) addAllIpAddrList:(NSArray*) values {
  if (result.mutableIpAddrListList == nil) {
    result.mutableIpAddrListList = [NSMutableArray array];
  }
  [result.mutableIpAddrListList addObjectsFromArray:values];
  return self;
}
- (IMFileNotify_Builder*) clearIpAddrListList {
  result.mutableIpAddrListList = nil;
  return self;
}
- (IMFileNotify_Builder*) addIpAddrList:(IpAddr*) value {
  if (result.mutableIpAddrListList == nil) {
    result.mutableIpAddrListList = [NSMutableArray array];
  }
  [result.mutableIpAddrListList addObject:value];
  return self;
}
- (BOOL) hasTransMode {
  return result.hasTransMode;
}
- (TransferFileType) transMode {
  return result.transMode;
}
- (IMFileNotify_Builder*) setTransMode:(TransferFileType) value {
  result.hasTransMode = YES;
  result.transMode = value;
  return self;
}
- (IMFileNotify_Builder*) clearTransMode {
  result.hasTransMode = NO;
  result.transMode = TransferFileTypeFileTypeOnline;
  return self;
}
- (BOOL) hasOfflineReady {
  return result.hasOfflineReady;
}
- (int32_t) offlineReady {
  return result.offlineReady;
}
- (IMFileNotify_Builder*) setOfflineReady:(int32_t) value {
  result.hasOfflineReady = YES;
  result.offlineReady = value;
  return self;
}
- (IMFileNotify_Builder*) clearOfflineReady {
  result.hasOfflineReady = NO;
  result.offlineReady = 0;
  return self;
}
@end

@interface IMFileHasOfflineReq ()
@property int32_t userId;
@property (retain) NSData* attachData;
@end

@implementation IMFileHasOfflineReq

- (BOOL) hasUserId {
  return !!hasUserId_;
}
- (void) setHasUserId:(BOOL) value {
  hasUserId_ = !!value;
}
@synthesize userId;
- (BOOL) hasAttachData {
  return !!hasAttachData_;
}
- (void) setHasAttachData:(BOOL) value {
  hasAttachData_ = !!value;
}
@synthesize attachData;
- (void) dealloc {
  self.attachData = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.userId = 0;
    self.attachData = [NSData data];
  }
  return self;
}
static IMFileHasOfflineReq* defaultIMFileHasOfflineReqInstance = nil;
+ (void) initialize {
  if (self == [IMFileHasOfflineReq class]) {
    defaultIMFileHasOfflineReqInstance = [[IMFileHasOfflineReq alloc] init];
  }
}
+ (IMFileHasOfflineReq*) defaultInstance {
  return defaultIMFileHasOfflineReqInstance;
}
- (IMFileHasOfflineReq*) defaultInstance {
  return defaultIMFileHasOfflineReqInstance;
}
- (BOOL) isInitialized {
  if (!self.hasUserId) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasUserId) {
    [output writeUInt32:1 value:self.userId];
  }
  if (self.hasAttachData) {
    [output writeData:20 value:self.attachData];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasUserId) {
    size += computeUInt32Size(1, self.userId);
  }
  if (self.hasAttachData) {
    size += computeDataSize(20, self.attachData);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileHasOfflineReq*) parseFromData:(NSData*) data {
  return (IMFileHasOfflineReq*)[[[IMFileHasOfflineReq builder] mergeFromData:data] build];
}
+ (IMFileHasOfflineReq*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileHasOfflineReq*)[[[IMFileHasOfflineReq builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileHasOfflineReq*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileHasOfflineReq*)[[[IMFileHasOfflineReq builder] mergeFromInputStream:input] build];
}
+ (IMFileHasOfflineReq*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileHasOfflineReq*)[[[IMFileHasOfflineReq builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileHasOfflineReq*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileHasOfflineReq*)[[[IMFileHasOfflineReq builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileHasOfflineReq*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileHasOfflineReq*)[[[IMFileHasOfflineReq builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileHasOfflineReq*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileHasOfflineReq*)[[[IMFileHasOfflineReq builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileHasOfflineReq_Builder*) builder {
  return [[[IMFileHasOfflineReq_Builder alloc] init] autorelease];
}
+ (IMFileHasOfflineReq_Builder*) builderWithPrototype:(IMFileHasOfflineReq*) prototype {
  return [[IMFileHasOfflineReq builder] mergeFrom:prototype];
}
- (IMFileHasOfflineReq_Builder*) builder {
  return [IMFileHasOfflineReq builder];
}
@end

@interface IMFileHasOfflineReq_Builder()
@property (retain) IMFileHasOfflineReq* result;
@end

@implementation IMFileHasOfflineReq_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileHasOfflineReq alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileHasOfflineReq_Builder*) clear {
  self.result = [[[IMFileHasOfflineReq alloc] init] autorelease];
  return self;
}
- (IMFileHasOfflineReq_Builder*) clone {
  return [IMFileHasOfflineReq builderWithPrototype:result];
}
- (IMFileHasOfflineReq*) defaultInstance {
  return [IMFileHasOfflineReq defaultInstance];
}
- (IMFileHasOfflineReq*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileHasOfflineReq*) buildPartial {
  IMFileHasOfflineReq* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileHasOfflineReq_Builder*) mergeFrom:(IMFileHasOfflineReq*) other {
  if (other == [IMFileHasOfflineReq defaultInstance]) {
    return self;
  }
  if (other.hasUserId) {
    [self setUserId:other.userId];
  }
  if (other.hasAttachData) {
    [self setAttachData:other.attachData];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileHasOfflineReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileHasOfflineReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setUserId:[input readUInt32]];
        break;
      }
      case 162: {
        [self setAttachData:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasUserId {
  return result.hasUserId;
}
- (int32_t) userId {
  return result.userId;
}
- (IMFileHasOfflineReq_Builder*) setUserId:(int32_t) value {
  result.hasUserId = YES;
  result.userId = value;
  return self;
}
- (IMFileHasOfflineReq_Builder*) clearUserId {
  result.hasUserId = NO;
  result.userId = 0;
  return self;
}
- (BOOL) hasAttachData {
  return result.hasAttachData;
}
- (NSData*) attachData {
  return result.attachData;
}
- (IMFileHasOfflineReq_Builder*) setAttachData:(NSData*) value {
  result.hasAttachData = YES;
  result.attachData = value;
  return self;
}
- (IMFileHasOfflineReq_Builder*) clearAttachData {
  result.hasAttachData = NO;
  result.attachData = [NSData data];
  return self;
}
@end

@interface IMFileHasOfflineRsp ()
@property int32_t userId;
@property (retain) NSMutableArray* mutableOfflineFileListList;
@property (retain) NSMutableArray* mutableIpAddrListList;
@property (retain) NSData* attachData;
@end

@implementation IMFileHasOfflineRsp

- (BOOL) hasUserId {
  return !!hasUserId_;
}
- (void) setHasUserId:(BOOL) value {
  hasUserId_ = !!value;
}
@synthesize userId;
@synthesize mutableOfflineFileListList;
@synthesize mutableIpAddrListList;
- (BOOL) hasAttachData {
  return !!hasAttachData_;
}
- (void) setHasAttachData:(BOOL) value {
  hasAttachData_ = !!value;
}
@synthesize attachData;
- (void) dealloc {
  self.mutableOfflineFileListList = nil;
  self.mutableIpAddrListList = nil;
  self.attachData = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.userId = 0;
    self.attachData = [NSData data];
  }
  return self;
}
static IMFileHasOfflineRsp* defaultIMFileHasOfflineRspInstance = nil;
+ (void) initialize {
  if (self == [IMFileHasOfflineRsp class]) {
    defaultIMFileHasOfflineRspInstance = [[IMFileHasOfflineRsp alloc] init];
  }
}
+ (IMFileHasOfflineRsp*) defaultInstance {
  return defaultIMFileHasOfflineRspInstance;
}
- (IMFileHasOfflineRsp*) defaultInstance {
  return defaultIMFileHasOfflineRspInstance;
}
- (NSArray*) offlineFileListList {
  return mutableOfflineFileListList;
}
- (OfflineFileInfo*) offlineFileListAtIndex:(int32_t) index {
  id value = [mutableOfflineFileListList objectAtIndex:index];
  return value;
}
- (NSArray*) ipAddrListList {
  return mutableIpAddrListList;
}
- (IpAddr*) ipAddrListAtIndex:(int32_t) index {
  id value = [mutableIpAddrListList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasUserId) {
    return NO;
  }
  for (OfflineFileInfo* element in self.offlineFileListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (IpAddr* element in self.ipAddrListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasUserId) {
    [output writeUInt32:1 value:self.userId];
  }
  for (OfflineFileInfo* element in self.offlineFileListList) {
    [output writeMessage:2 value:element];
  }
  for (IpAddr* element in self.ipAddrListList) {
    [output writeMessage:3 value:element];
  }
  if (self.hasAttachData) {
    [output writeData:20 value:self.attachData];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasUserId) {
    size += computeUInt32Size(1, self.userId);
  }
  for (OfflineFileInfo* element in self.offlineFileListList) {
    size += computeMessageSize(2, element);
  }
  for (IpAddr* element in self.ipAddrListList) {
    size += computeMessageSize(3, element);
  }
  if (self.hasAttachData) {
    size += computeDataSize(20, self.attachData);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileHasOfflineRsp*) parseFromData:(NSData*) data {
  return (IMFileHasOfflineRsp*)[[[IMFileHasOfflineRsp builder] mergeFromData:data] build];
}
+ (IMFileHasOfflineRsp*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileHasOfflineRsp*)[[[IMFileHasOfflineRsp builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileHasOfflineRsp*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileHasOfflineRsp*)[[[IMFileHasOfflineRsp builder] mergeFromInputStream:input] build];
}
+ (IMFileHasOfflineRsp*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileHasOfflineRsp*)[[[IMFileHasOfflineRsp builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileHasOfflineRsp*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileHasOfflineRsp*)[[[IMFileHasOfflineRsp builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileHasOfflineRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileHasOfflineRsp*)[[[IMFileHasOfflineRsp builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileHasOfflineRsp*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileHasOfflineRsp*)[[[IMFileHasOfflineRsp builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileHasOfflineRsp_Builder*) builder {
  return [[[IMFileHasOfflineRsp_Builder alloc] init] autorelease];
}
+ (IMFileHasOfflineRsp_Builder*) builderWithPrototype:(IMFileHasOfflineRsp*) prototype {
  return [[IMFileHasOfflineRsp builder] mergeFrom:prototype];
}
- (IMFileHasOfflineRsp_Builder*) builder {
  return [IMFileHasOfflineRsp builder];
}
@end

@interface IMFileHasOfflineRsp_Builder()
@property (retain) IMFileHasOfflineRsp* result;
@end

@implementation IMFileHasOfflineRsp_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileHasOfflineRsp alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileHasOfflineRsp_Builder*) clear {
  self.result = [[[IMFileHasOfflineRsp alloc] init] autorelease];
  return self;
}
- (IMFileHasOfflineRsp_Builder*) clone {
  return [IMFileHasOfflineRsp builderWithPrototype:result];
}
- (IMFileHasOfflineRsp*) defaultInstance {
  return [IMFileHasOfflineRsp defaultInstance];
}
- (IMFileHasOfflineRsp*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileHasOfflineRsp*) buildPartial {
  IMFileHasOfflineRsp* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileHasOfflineRsp_Builder*) mergeFrom:(IMFileHasOfflineRsp*) other {
  if (other == [IMFileHasOfflineRsp defaultInstance]) {
    return self;
  }
  if (other.hasUserId) {
    [self setUserId:other.userId];
  }
  if (other.mutableOfflineFileListList.count > 0) {
    if (result.mutableOfflineFileListList == nil) {
      result.mutableOfflineFileListList = [NSMutableArray array];
    }
    [result.mutableOfflineFileListList addObjectsFromArray:other.mutableOfflineFileListList];
  }
  if (other.mutableIpAddrListList.count > 0) {
    if (result.mutableIpAddrListList == nil) {
      result.mutableIpAddrListList = [NSMutableArray array];
    }
    [result.mutableIpAddrListList addObjectsFromArray:other.mutableIpAddrListList];
  }
  if (other.hasAttachData) {
    [self setAttachData:other.attachData];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileHasOfflineRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileHasOfflineRsp_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setUserId:[input readUInt32]];
        break;
      }
      case 18: {
        OfflineFileInfo_Builder* subBuilder = [OfflineFileInfo builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addOfflineFileList:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        IpAddr_Builder* subBuilder = [IpAddr builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addIpAddrList:[subBuilder buildPartial]];
        break;
      }
      case 162: {
        [self setAttachData:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasUserId {
  return result.hasUserId;
}
- (int32_t) userId {
  return result.userId;
}
- (IMFileHasOfflineRsp_Builder*) setUserId:(int32_t) value {
  result.hasUserId = YES;
  result.userId = value;
  return self;
}
- (IMFileHasOfflineRsp_Builder*) clearUserId {
  result.hasUserId = NO;
  result.userId = 0;
  return self;
}
- (NSArray*) offlineFileListList {
  if (result.mutableOfflineFileListList == nil) { return [NSArray array]; }
  return result.mutableOfflineFileListList;
}
- (OfflineFileInfo*) offlineFileListAtIndex:(int32_t) index {
  return [result offlineFileListAtIndex:index];
}
- (IMFileHasOfflineRsp_Builder*) replaceOfflineFileListAtIndex:(int32_t) index with:(OfflineFileInfo*) value {
  [result.mutableOfflineFileListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (IMFileHasOfflineRsp_Builder*) addAllOfflineFileList:(NSArray*) values {
  if (result.mutableOfflineFileListList == nil) {
    result.mutableOfflineFileListList = [NSMutableArray array];
  }
  [result.mutableOfflineFileListList addObjectsFromArray:values];
  return self;
}
- (IMFileHasOfflineRsp_Builder*) clearOfflineFileListList {
  result.mutableOfflineFileListList = nil;
  return self;
}
- (IMFileHasOfflineRsp_Builder*) addOfflineFileList:(OfflineFileInfo*) value {
  if (result.mutableOfflineFileListList == nil) {
    result.mutableOfflineFileListList = [NSMutableArray array];
  }
  [result.mutableOfflineFileListList addObject:value];
  return self;
}
- (NSArray*) ipAddrListList {
  if (result.mutableIpAddrListList == nil) { return [NSArray array]; }
  return result.mutableIpAddrListList;
}
- (IpAddr*) ipAddrListAtIndex:(int32_t) index {
  return [result ipAddrListAtIndex:index];
}
- (IMFileHasOfflineRsp_Builder*) replaceIpAddrListAtIndex:(int32_t) index with:(IpAddr*) value {
  [result.mutableIpAddrListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (IMFileHasOfflineRsp_Builder*) addAllIpAddrList:(NSArray*) values {
  if (result.mutableIpAddrListList == nil) {
    result.mutableIpAddrListList = [NSMutableArray array];
  }
  [result.mutableIpAddrListList addObjectsFromArray:values];
  return self;
}
- (IMFileHasOfflineRsp_Builder*) clearIpAddrListList {
  result.mutableIpAddrListList = nil;
  return self;
}
- (IMFileHasOfflineRsp_Builder*) addIpAddrList:(IpAddr*) value {
  if (result.mutableIpAddrListList == nil) {
    result.mutableIpAddrListList = [NSMutableArray array];
  }
  [result.mutableIpAddrListList addObject:value];
  return self;
}
- (BOOL) hasAttachData {
  return result.hasAttachData;
}
- (NSData*) attachData {
  return result.attachData;
}
- (IMFileHasOfflineRsp_Builder*) setAttachData:(NSData*) value {
  result.hasAttachData = YES;
  result.attachData = value;
  return self;
}
- (IMFileHasOfflineRsp_Builder*) clearAttachData {
  result.hasAttachData = NO;
  result.attachData = [NSData data];
  return self;
}
@end

@interface IMFileAddOfflineReq ()
@property int32_t fromUserId;
@property int32_t toUserId;
@property (retain) NSString* taskId;
@property (retain) NSString* fileName;
@property int32_t fileSize;
@property (retain) NSString* fileMd5;
@property int32_t status;
@end

@implementation IMFileAddOfflineReq

- (BOOL) hasFromUserId {
  return !!hasFromUserId_;
}
- (void) setHasFromUserId:(BOOL) value {
  hasFromUserId_ = !!value;
}
@synthesize fromUserId;
- (BOOL) hasToUserId {
  return !!hasToUserId_;
}
- (void) setHasToUserId:(BOOL) value {
  hasToUserId_ = !!value;
}
@synthesize toUserId;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
- (BOOL) hasFileName {
  return !!hasFileName_;
}
- (void) setHasFileName:(BOOL) value {
  hasFileName_ = !!value;
}
@synthesize fileName;
- (BOOL) hasFileSize {
  return !!hasFileSize_;
}
- (void) setHasFileSize:(BOOL) value {
  hasFileSize_ = !!value;
}
@synthesize fileSize;
- (BOOL) hasFileMd5 {
  return !!hasFileMd5_;
}
- (void) setHasFileMd5:(BOOL) value {
  hasFileMd5_ = !!value;
}
@synthesize fileMd5;
- (BOOL) hasStatus {
  return !!hasStatus_;
}
- (void) setHasStatus:(BOOL) value {
  hasStatus_ = !!value;
}
@synthesize status;
- (void) dealloc {
  self.taskId = nil;
  self.fileName = nil;
  self.fileMd5 = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fromUserId = 0;
    self.toUserId = 0;
    self.taskId = @"";
    self.fileName = @"";
    self.fileSize = 0;
    self.fileMd5 = @"";
    self.status = 0;
  }
  return self;
}
static IMFileAddOfflineReq* defaultIMFileAddOfflineReqInstance = nil;
+ (void) initialize {
  if (self == [IMFileAddOfflineReq class]) {
    defaultIMFileAddOfflineReqInstance = [[IMFileAddOfflineReq alloc] init];
  }
}
+ (IMFileAddOfflineReq*) defaultInstance {
  return defaultIMFileAddOfflineReqInstance;
}
- (IMFileAddOfflineReq*) defaultInstance {
  return defaultIMFileAddOfflineReqInstance;
}
- (BOOL) isInitialized {
  if (!self.hasFromUserId) {
    return NO;
  }
  if (!self.hasToUserId) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasFileName) {
    return NO;
  }
  if (!self.hasFileSize) {
    return NO;
  }
  if (!self.hasFileMd5) {
    return NO;
  }
  if (!self.hasStatus) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFromUserId) {
    [output writeUInt32:1 value:self.fromUserId];
  }
  if (self.hasToUserId) {
    [output writeUInt32:2 value:self.toUserId];
  }
  if (self.hasTaskId) {
    [output writeString:3 value:self.taskId];
  }
  if (self.hasFileName) {
    [output writeString:4 value:self.fileName];
  }
  if (self.hasFileSize) {
    [output writeUInt32:5 value:self.fileSize];
  }
  if (self.hasFileMd5) {
    [output writeString:6 value:self.fileMd5];
  }
  if (self.hasStatus) {
    [output writeUInt32:7 value:self.status];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFromUserId) {
    size += computeUInt32Size(1, self.fromUserId);
  }
  if (self.hasToUserId) {
    size += computeUInt32Size(2, self.toUserId);
  }
  if (self.hasTaskId) {
    size += computeStringSize(3, self.taskId);
  }
  if (self.hasFileName) {
    size += computeStringSize(4, self.fileName);
  }
  if (self.hasFileSize) {
    size += computeUInt32Size(5, self.fileSize);
  }
  if (self.hasFileMd5) {
    size += computeStringSize(6, self.fileMd5);
  }
  if (self.hasStatus) {
    size += computeUInt32Size(7, self.status);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileAddOfflineReq*) parseFromData:(NSData*) data {
  return (IMFileAddOfflineReq*)[[[IMFileAddOfflineReq builder] mergeFromData:data] build];
}
+ (IMFileAddOfflineReq*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileAddOfflineReq*)[[[IMFileAddOfflineReq builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileAddOfflineReq*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileAddOfflineReq*)[[[IMFileAddOfflineReq builder] mergeFromInputStream:input] build];
}
+ (IMFileAddOfflineReq*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileAddOfflineReq*)[[[IMFileAddOfflineReq builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileAddOfflineReq*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileAddOfflineReq*)[[[IMFileAddOfflineReq builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileAddOfflineReq*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileAddOfflineReq*)[[[IMFileAddOfflineReq builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileAddOfflineReq*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileAddOfflineReq*)[[[IMFileAddOfflineReq builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileAddOfflineReq_Builder*) builder {
  return [[[IMFileAddOfflineReq_Builder alloc] init] autorelease];
}
+ (IMFileAddOfflineReq_Builder*) builderWithPrototype:(IMFileAddOfflineReq*) prototype {
  return [[IMFileAddOfflineReq builder] mergeFrom:prototype];
}
- (IMFileAddOfflineReq_Builder*) builder {
  return [IMFileAddOfflineReq builder];
}
@end

@interface IMFileAddOfflineReq_Builder()
@property (retain) IMFileAddOfflineReq* result;
@end

@implementation IMFileAddOfflineReq_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileAddOfflineReq alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileAddOfflineReq_Builder*) clear {
  self.result = [[[IMFileAddOfflineReq alloc] init] autorelease];
  return self;
}
- (IMFileAddOfflineReq_Builder*) clone {
  return [IMFileAddOfflineReq builderWithPrototype:result];
}
- (IMFileAddOfflineReq*) defaultInstance {
  return [IMFileAddOfflineReq defaultInstance];
}
- (IMFileAddOfflineReq*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileAddOfflineReq*) buildPartial {
  IMFileAddOfflineReq* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileAddOfflineReq_Builder*) mergeFrom:(IMFileAddOfflineReq*) other {
  if (other == [IMFileAddOfflineReq defaultInstance]) {
    return self;
  }
  if (other.hasFromUserId) {
    [self setFromUserId:other.fromUserId];
  }
  if (other.hasToUserId) {
    [self setToUserId:other.toUserId];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.hasFileName) {
    [self setFileName:other.fileName];
  }
  if (other.hasFileSize) {
    [self setFileSize:other.fileSize];
  }
  if (other.hasFileMd5) {
    [self setFileMd5:other.fileMd5];
  }
  if (other.hasStatus) {
    [self setStatus:other.status];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileAddOfflineReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileAddOfflineReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setFromUserId:[input readUInt32]];
        break;
      }
      case 16: {
        [self setToUserId:[input readUInt32]];
        break;
      }
      case 26: {
        [self setTaskId:[input readString]];
        break;
      }
      case 34: {
        [self setFileName:[input readString]];
        break;
      }
      case 40: {
        [self setFileSize:[input readUInt32]];
        break;
      }
      case 50: {
        [self setFileMd5:[input readString]];
        break;
      }
      case 56: {
        [self setStatus:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasFromUserId {
  return result.hasFromUserId;
}
- (int32_t) fromUserId {
  return result.fromUserId;
}
- (IMFileAddOfflineReq_Builder*) setFromUserId:(int32_t) value {
  result.hasFromUserId = YES;
  result.fromUserId = value;
  return self;
}
- (IMFileAddOfflineReq_Builder*) clearFromUserId {
  result.hasFromUserId = NO;
  result.fromUserId = 0;
  return self;
}
- (BOOL) hasToUserId {
  return result.hasToUserId;
}
- (int32_t) toUserId {
  return result.toUserId;
}
- (IMFileAddOfflineReq_Builder*) setToUserId:(int32_t) value {
  result.hasToUserId = YES;
  result.toUserId = value;
  return self;
}
- (IMFileAddOfflineReq_Builder*) clearToUserId {
  result.hasToUserId = NO;
  result.toUserId = 0;
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFileAddOfflineReq_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFileAddOfflineReq_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (BOOL) hasFileName {
  return result.hasFileName;
}
- (NSString*) fileName {
  return result.fileName;
}
- (IMFileAddOfflineReq_Builder*) setFileName:(NSString*) value {
  result.hasFileName = YES;
  result.fileName = value;
  return self;
}
- (IMFileAddOfflineReq_Builder*) clearFileName {
  result.hasFileName = NO;
  result.fileName = @"";
  return self;
}
- (BOOL) hasFileSize {
  return result.hasFileSize;
}
- (int32_t) fileSize {
  return result.fileSize;
}
- (IMFileAddOfflineReq_Builder*) setFileSize:(int32_t) value {
  result.hasFileSize = YES;
  result.fileSize = value;
  return self;
}
- (IMFileAddOfflineReq_Builder*) clearFileSize {
  result.hasFileSize = NO;
  result.fileSize = 0;
  return self;
}
- (BOOL) hasFileMd5 {
  return result.hasFileMd5;
}
- (NSString*) fileMd5 {
  return result.fileMd5;
}
- (IMFileAddOfflineReq_Builder*) setFileMd5:(NSString*) value {
  result.hasFileMd5 = YES;
  result.fileMd5 = value;
  return self;
}
- (IMFileAddOfflineReq_Builder*) clearFileMd5 {
  result.hasFileMd5 = NO;
  result.fileMd5 = @"";
  return self;
}
- (BOOL) hasStatus {
  return result.hasStatus;
}
- (int32_t) status {
  return result.status;
}
- (IMFileAddOfflineReq_Builder*) setStatus:(int32_t) value {
  result.hasStatus = YES;
  result.status = value;
  return self;
}
- (IMFileAddOfflineReq_Builder*) clearStatus {
  result.hasStatus = NO;
  result.status = 0;
  return self;
}
@end

@interface IMFileDelOfflineReq ()
@property int32_t fromUserId;
@property int32_t toUserId;
@property (retain) NSString* taskId;
@property (retain) NSString* fileName;
@property int32_t fileSize;
@end

@implementation IMFileDelOfflineReq

- (BOOL) hasFromUserId {
  return !!hasFromUserId_;
}
- (void) setHasFromUserId:(BOOL) value {
  hasFromUserId_ = !!value;
}
@synthesize fromUserId;
- (BOOL) hasToUserId {
  return !!hasToUserId_;
}
- (void) setHasToUserId:(BOOL) value {
  hasToUserId_ = !!value;
}
@synthesize toUserId;
- (BOOL) hasTaskId {
  return !!hasTaskId_;
}
- (void) setHasTaskId:(BOOL) value {
  hasTaskId_ = !!value;
}
@synthesize taskId;
- (BOOL) hasFileName {
  return !!hasFileName_;
}
- (void) setHasFileName:(BOOL) value {
  hasFileName_ = !!value;
}
@synthesize fileName;
- (BOOL) hasFileSize {
  return !!hasFileSize_;
}
- (void) setHasFileSize:(BOOL) value {
  hasFileSize_ = !!value;
}
@synthesize fileSize;
- (void) dealloc {
  self.taskId = nil;
  self.fileName = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fromUserId = 0;
    self.toUserId = 0;
    self.taskId = @"";
    self.fileName = @"";
    self.fileSize = 0;
  }
  return self;
}
static IMFileDelOfflineReq* defaultIMFileDelOfflineReqInstance = nil;
+ (void) initialize {
  if (self == [IMFileDelOfflineReq class]) {
    defaultIMFileDelOfflineReqInstance = [[IMFileDelOfflineReq alloc] init];
  }
}
+ (IMFileDelOfflineReq*) defaultInstance {
  return defaultIMFileDelOfflineReqInstance;
}
- (IMFileDelOfflineReq*) defaultInstance {
  return defaultIMFileDelOfflineReqInstance;
}
- (BOOL) isInitialized {
  if (!self.hasFromUserId) {
    return NO;
  }
  if (!self.hasToUserId) {
    return NO;
  }
  if (!self.hasTaskId) {
    return NO;
  }
  if (!self.hasFileName) {
    return NO;
  }
  if (!self.hasFileSize) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFromUserId) {
    [output writeUInt32:1 value:self.fromUserId];
  }
  if (self.hasToUserId) {
    [output writeUInt32:2 value:self.toUserId];
  }
  if (self.hasTaskId) {
    [output writeString:3 value:self.taskId];
  }
  if (self.hasFileName) {
    [output writeString:4 value:self.fileName];
  }
  if (self.hasFileSize) {
    [output writeUInt32:5 value:self.fileSize];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFromUserId) {
    size += computeUInt32Size(1, self.fromUserId);
  }
  if (self.hasToUserId) {
    size += computeUInt32Size(2, self.toUserId);
  }
  if (self.hasTaskId) {
    size += computeStringSize(3, self.taskId);
  }
  if (self.hasFileName) {
    size += computeStringSize(4, self.fileName);
  }
  if (self.hasFileSize) {
    size += computeUInt32Size(5, self.fileSize);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (IMFileDelOfflineReq*) parseFromData:(NSData*) data {
  return (IMFileDelOfflineReq*)[[[IMFileDelOfflineReq builder] mergeFromData:data] build];
}
+ (IMFileDelOfflineReq*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileDelOfflineReq*)[[[IMFileDelOfflineReq builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (IMFileDelOfflineReq*) parseFromInputStream:(NSInputStream*) input {
  return (IMFileDelOfflineReq*)[[[IMFileDelOfflineReq builder] mergeFromInputStream:input] build];
}
+ (IMFileDelOfflineReq*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (IMFileDelOfflineReq*)[[[IMFileDelOfflineReq builder] mergeDelimitedFromInputStream:input] build];
}
+ (IMFileDelOfflineReq*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileDelOfflineReq*)[[[IMFileDelOfflineReq builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileDelOfflineReq*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (IMFileDelOfflineReq*)[[[IMFileDelOfflineReq builder] mergeFromCodedInputStream:input] build];
}
+ (IMFileDelOfflineReq*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (IMFileDelOfflineReq*)[[[IMFileDelOfflineReq builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (IMFileDelOfflineReq_Builder*) builder {
  return [[[IMFileDelOfflineReq_Builder alloc] init] autorelease];
}
+ (IMFileDelOfflineReq_Builder*) builderWithPrototype:(IMFileDelOfflineReq*) prototype {
  return [[IMFileDelOfflineReq builder] mergeFrom:prototype];
}
- (IMFileDelOfflineReq_Builder*) builder {
  return [IMFileDelOfflineReq builder];
}
@end

@interface IMFileDelOfflineReq_Builder()
@property (retain) IMFileDelOfflineReq* result;
@end

@implementation IMFileDelOfflineReq_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[IMFileDelOfflineReq alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (IMFileDelOfflineReq_Builder*) clear {
  self.result = [[[IMFileDelOfflineReq alloc] init] autorelease];
  return self;
}
- (IMFileDelOfflineReq_Builder*) clone {
  return [IMFileDelOfflineReq builderWithPrototype:result];
}
- (IMFileDelOfflineReq*) defaultInstance {
  return [IMFileDelOfflineReq defaultInstance];
}
- (IMFileDelOfflineReq*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (IMFileDelOfflineReq*) buildPartial {
  IMFileDelOfflineReq* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (IMFileDelOfflineReq_Builder*) mergeFrom:(IMFileDelOfflineReq*) other {
  if (other == [IMFileDelOfflineReq defaultInstance]) {
    return self;
  }
  if (other.hasFromUserId) {
    [self setFromUserId:other.fromUserId];
  }
  if (other.hasToUserId) {
    [self setToUserId:other.toUserId];
  }
  if (other.hasTaskId) {
    [self setTaskId:other.taskId];
  }
  if (other.hasFileName) {
    [self setFileName:other.fileName];
  }
  if (other.hasFileSize) {
    [self setFileSize:other.fileSize];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (IMFileDelOfflineReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (IMFileDelOfflineReq_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setFromUserId:[input readUInt32]];
        break;
      }
      case 16: {
        [self setToUserId:[input readUInt32]];
        break;
      }
      case 26: {
        [self setTaskId:[input readString]];
        break;
      }
      case 34: {
        [self setFileName:[input readString]];
        break;
      }
      case 40: {
        [self setFileSize:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasFromUserId {
  return result.hasFromUserId;
}
- (int32_t) fromUserId {
  return result.fromUserId;
}
- (IMFileDelOfflineReq_Builder*) setFromUserId:(int32_t) value {
  result.hasFromUserId = YES;
  result.fromUserId = value;
  return self;
}
- (IMFileDelOfflineReq_Builder*) clearFromUserId {
  result.hasFromUserId = NO;
  result.fromUserId = 0;
  return self;
}
- (BOOL) hasToUserId {
  return result.hasToUserId;
}
- (int32_t) toUserId {
  return result.toUserId;
}
- (IMFileDelOfflineReq_Builder*) setToUserId:(int32_t) value {
  result.hasToUserId = YES;
  result.toUserId = value;
  return self;
}
- (IMFileDelOfflineReq_Builder*) clearToUserId {
  result.hasToUserId = NO;
  result.toUserId = 0;
  return self;
}
- (BOOL) hasTaskId {
  return result.hasTaskId;
}
- (NSString*) taskId {
  return result.taskId;
}
- (IMFileDelOfflineReq_Builder*) setTaskId:(NSString*) value {
  result.hasTaskId = YES;
  result.taskId = value;
  return self;
}
- (IMFileDelOfflineReq_Builder*) clearTaskId {
  result.hasTaskId = NO;
  result.taskId = @"";
  return self;
}
- (BOOL) hasFileName {
  return result.hasFileName;
}
- (NSString*) fileName {
  return result.fileName;
}
- (IMFileDelOfflineReq_Builder*) setFileName:(NSString*) value {
  result.hasFileName = YES;
  result.fileName = value;
  return self;
}
- (IMFileDelOfflineReq_Builder*) clearFileName {
  result.hasFileName = NO;
  result.fileName = @"";
  return self;
}
- (BOOL) hasFileSize {
  return result.hasFileSize;
}
- (int32_t) fileSize {
  return result.fileSize;
}
- (IMFileDelOfflineReq_Builder*) setFileSize:(int32_t) value {
  result.hasFileSize = YES;
  result.fileSize = value;
  return self;
}
- (IMFileDelOfflineReq_Builder*) clearFileSize {
  result.hasFileSize = NO;
  result.fileSize = 0;
  return self;
}
@end

